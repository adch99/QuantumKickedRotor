15a16
> # from numba import jit
17,29c18
< from cython.parallel import prange
< cimport cython
< 
< from libc.math cimport sqrt
< 
< cdef extern from "complex.h":
<     double cos(double x) nogil
<     double sin(double x) nogil
<     float complex I
< 
< cdef extern from "math.h":
<     float M_PI
< 
---
> import cython
31,35c20,24
< cdef float HBAR = 2.89
< cdef float K = 5
< cdef float ALPHA = 0.5
< cdef float OMEGA2 = 2 * M_PI * sqrt(5)
< cdef float OMEGA3 = 2 * M_PI * sqrt(13)
---
> HBAR = 1
> K = 5
> ALPHA = 0.1
> OMEGA2 = 0.9
> OMEGA3 = 1.2
38,51c27,30
< cdef int N = 1
< cdef int DIM = 2 * N + 1
< cdef float EPSILON = 1e-6
< cdef int TIMESTEPS = 5
< 
< def printMatrix(matrix, name):
<     """
<     Prints the given matrix prettily. For debugging purposes.
<     """
<     print(f"{name}:")
<     print("-"*len(name))
<     print(matrix)
<     print()
< 
---
> N = 10
> DIM = 2 * N + 1
> EPSILON = 1e-6
> TIMESTEPS = 1
68,69c47,48
<     state23 = np.kron(state2, state2)
<     return np.kron(state1, state23)
---
>     state23 = np.tensordot(state2, state2, axes=0)
>     return np.tensordot(state1, state23, axes=0)
85c64
<     y = fft.fftshift(fft.fftn(x, norm="ortho"))
---
>     y = fft.fftshift(fft.fftn(x))
88,89d66
< cdef float complex complex_exp(float angle) nogil:
<     return cos(angle) + I * sin(angle)
91,93c68,69
< @cython.boundscheck(False)
< @cython.wraparound(False)
< def getDenseFloquetOperator(float complex[:, :, :] fourier_coeffs):
---
> # @jit(nopython=True, parallel=True)
> def getDenseFloquetOperator(fourier_coeffs):
97,120c73,76
< 
<     F = np.zeros((DIM,)*6, dtype=np.complex64)
<     cdef float complex[:, :, :, :, :, :] F_view = F
< 
<     cdef int m1, m2, m3, n1, n2, n3
<     # cdef int row, col
<     cdef float angle
<     cdef float norm = 1 /(2 * M_PI)**1.5
<     # cdef float norm = 1
<     cdef float complex fourier
< 
<     for m1 in prange(-N, N+1, nogil=True):
<         for m2 in prange(-N, N+1):
<             for m3 in prange(-N, N+1):
<                 for n1 in prange(-N, N+1):
<                     for n2 in prange(-N, N+1):
<                         for n3 in prange(-N, N+1):
<                             angle = (HBAR / 2) * m1**2 + m2 * OMEGA2 + m3 * OMEGA3
<                             fourier = fourier_coeffs[m1-n1+2*N, m2-n2+2*N, m3-n3+2*N]
<                             # row = (m1 + N) * (DIM**2) + (m2 + N) * DIM + (m3 + N)
<                             # col = (n1 + N) * (DIM**2) + (m3 + N) * DIM + (n3 + N)
<                             F_view[m1+N, m2+N, m3+N, n1+N, n2+N, n3+N] = \
<                               complex_exp(-angle) * fourier * norm
< 
---
>     m = np.arange(-N, N+1, dtype=int)
>     m1, n1, m2, n2, m3, n3 = np.meshgrid(*(m,)*6)
>     F = np.exp(-1j * (HBAR * m1**2 / 2) + m2 * OMEGA2 + m3 * OMEGA3) \
>         * fourier_coeffs[m1-n1+2*N, m2-n2+2*N, m3-n3+2*N] / (2 * np.pi)**1.5
129,130d84
<     # assert np.allclose(np.abs(fourier_coeffs - 1), 0)
<     # print(np.max(np.abs(fourier_coeffs - 1)))
132,139d85
<     # F /= np.linalg.det(F)
<     sign, logdet = np.linalg.slogdet(F)
<     print(f"slogdet(F) = {sign} * exp({logdet})")
<     # F *= np.exp(-logdet) / sign
<     # Fh = np.conjugate(F.T)
<     # print("F x Fh:", F.dot(Fh))
<     with np.printoptions(precision=4, threshold=np.inf, suppress=True):
<       printMatrix(F, "F")
142c88
<     return csr_matrix(F), csr_matrix(Fh)
---
>     return csr_matrix(F), csc_matrix(Fh)
148c94
<     return csr_matrix.dot(F.dot(rho), Fh)
---
>     return csc_matrix.dot(F.dot(rho), Fh)
155c101
<     return np.einsum("ijkljk", rho_product) # Einstein Summation Convention
---
>     return np.einsum("ijkkll", rho_product) # Einstein Summation Convention
171c117
<     ax.semilogy(t, entropies, marker="o")
---
>     ax.plot(t, entropies, marker="o")
180d125
<     print("Starting to compute F...")
182,183d126
<     # print(f"F has {F.count_nonzero()} non-zero elements out of {DIM**6}")
<     print("Floquet operator computation over. Density operator starting...")
185,189d127
<     rho1 = partialTrace(rho)
<     print("Trace of rho:", np.trace(rho))
<     print("Trace of rho1:", np.trace(rho1))
<     print("von Neumann Entropy:", getEntanglementEntropy(rho1))
< 
191c129
<     print("Starting evolution...")
---
> 
193d130
<         print(f"Iteration {t} starting...")
195,198c132
<         print(f"Trace of rho1: {np.trace(rho1)}")
<         entropy = getEntanglementEntropy(rho1)
<         print(f"Calculated von Neumann entropy is: {entropy}")
<         entropies[t] = entropy
---
>         entropies[t] = getEntanglementEntropy(rho1)
200d133
<         print()
